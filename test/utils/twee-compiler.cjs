/**
 * Twee Compiler Utility
 * Compiles Twee files to HTML using Extwee and our Snowman format
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class TweeCompiler {
    constructor() {
        this.formatPath = path.join(__dirname, '../../dist/format.js');
        this.tempDir = path.join(__dirname, '../temp');
        
        // Ensure temp directory exists
        if (!fs.existsSync(this.tempDir)) {
            fs.mkdirSync(this.tempDir, { recursive: true });
        }
    }

    /**
     * Compile a Twee file to HTML using Extwee
     * @param {string} tweeFilePath - Path to the Twee file
     * @param {Object} options - Compilation options
     * @returns {Promise<string>} Generated HTML content
     */
    async compileTweeFile(tweeFilePath, options = {}) {
        const {
            outputPath = null,
            storyFormat = 'snowman',
            storyFormatVersion = '2.1.0',
            useCustomFormat = true
        } = options;

        try {
            // Read the Twee file
            const tweeContent = fs.readFileSync(tweeFilePath, 'utf8');
            
            // Create temporary files
            const tempTweeFile = path.join(this.tempDir, `temp_${Date.now()}.twee`);
            const tempHtmlFile = path.join(this.tempDir, `temp_${Date.now()}.html`);
            
            // Add IFID if missing
            let processedContent = tweeContent;
            if (!tweeContent.includes(':: StoryData')) {
                const ifid = this.generateIFID();
                const storyData = `:: StoryData\n{\n    "ifid": "${ifid}",\n    "format": "Snowman",\n    "format-version": "2.1.0"\n}\n\n`;
                processedContent = storyData + tweeContent;
            }
            
            // Write Twee content to temp file
            fs.writeFileSync(tempTweeFile, processedContent);
            
            let html;
            
            if (useCustomFormat && fs.existsSync(this.formatPath)) {
                // Use our custom Snowman format
                html = await this.compileWithCustomFormat(tempTweeFile, tempHtmlFile);
            } else {
                // Use Extwee with built-in Snowman format
                html = await this.compileWithExtwee(tempTweeFile, tempHtmlFile, storyFormat, storyFormatVersion);
            }
            
            // Clean up temp files
            this.cleanupTempFiles([tempTweeFile, tempHtmlFile]);
            
            // Optionally save to output path
            if (outputPath) {
                fs.writeFileSync(outputPath, html);
            }
            
            return html;
            
        } catch (error) {
            throw new Error(`Failed to compile Twee file ${tweeFilePath}: ${error.message}`);
        }
    }

    /**
     * Compile using our custom Snowman format
     * @param {string} tweeFile - Input Twee file
     * @param {string} htmlFile - Output HTML file
     * @returns {Promise<string>} Generated HTML
     */
    async compileWithCustomFormat(tweeFile, htmlFile) {
        try {
            // Use Extwee with our custom format
            const command = `npx extwee -c -i ${tweeFile} -o ${htmlFile} -s ${this.formatPath}`;
            
            execSync(command, { 
                cwd: path.dirname(this.formatPath),
                stdio: 'pipe'
            });
            
            if (fs.existsSync(htmlFile)) {
                return fs.readFileSync(htmlFile, 'utf8');
            } else {
                throw new Error('HTML file was not generated');
            }
            
        } catch (error) {
            // Fallback to built-in Snowman format
            console.warn(`Custom format compilation failed: ${error.message}. Falling back to built-in Snowman.`);
            return this.compileWithExtwee(tweeFile, htmlFile, 'snowman', '2.1.0');
        }
    }

    /**
     * Compile using Extwee's built-in Snowman format
     * @param {string} tweeFile - Input Twee file
     * @param {string} htmlFile - Output HTML file
     * @param {string} format - Story format name
     * @param {string} version - Format version
     * @returns {Promise<string>} Generated HTML
     */
    async compileWithExtwee(tweeFile, htmlFile, format = 'snowman', version = '2.1.0') {
        try {
            const command = `npx extwee -c -i ${tweeFile} -o ${htmlFile} -s ${format}`;
            
            execSync(command, { 
                stdio: 'pipe',
                timeout: 30000 // 30 second timeout
            });
            
            if (fs.existsSync(htmlFile)) {
                return fs.readFileSync(htmlFile, 'utf8');
            } else {
                throw new Error('HTML file was not generated by Extwee');
            }
            
        } catch (error) {
            throw new Error(`Extwee compilation failed: ${error.message}`);
        }
    }

    /**
     * Parse Twee content into structured data
     * @param {string} tweeContent - Raw Twee content
     * @returns {Object} Parsed story data
     */
    parseTweeContent(tweeContent) {
        const story = {
            title: null,
            author: null,
            ifid: null,
            passages: []
        };
        
        const lines = tweeContent.split('\n');
        let currentPassage = null;
        let inPassage = false;
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmed = line.trim();
            
            // Check for story metadata
            if (trimmed.startsWith(':: StoryTitle')) {
                const nextLine = lines[i + 1];
                if (nextLine && !nextLine.trim().startsWith('::')) {
                    story.title = nextLine.trim();
                }
                continue;
            }
            
            if (trimmed.startsWith(':: StoryAuthor')) {
                const nextLine = lines[i + 1];
                if (nextLine && !nextLine.trim().startsWith('::')) {
                    story.author = nextLine.trim();
                }
                continue;
            }
            
            // Check for passage headers
            if (trimmed.startsWith('::')) {
                // Save previous passage
                if (currentPassage) {
                    story.passages.push(currentPassage);
                }
                
                // Parse new passage header
                const passageMatch = trimmed.match(/^::\s*([^\[\{]+?)(?:\s*\[([^\]]*)\])?(?:\s*\{([^\}]*)\})?$/);
                if (passageMatch) {
                    currentPassage = {
                        name: passageMatch[1].trim(),
                        tags: passageMatch[2] ? passageMatch[2].split(/\s+/).filter(t => t) : [],
                        metadata: passageMatch[3] ? passageMatch[3].trim() : '',
                        content: ''
                    };
                    inPassage = true;
                }
                continue;
            }
            
            // Add content to current passage
            if (inPassage && currentPassage) {
                currentPassage.content += line + '\n';
            }
        }
        
        // Add the last passage
        if (currentPassage) {
            story.passages.push(currentPassage);
        }
        
        return story;
    }

    /**
     * Generate HTML using our Story class directly (alternative to Extwee)
     * @param {string} tweeContent - Twee file content
     * @returns {string} Generated HTML
     */
    compileWithStoryClass(tweeContent) {
        // This is a fallback method that uses our Story class directly
        // Import our classes
        const { Story } = require('../../src/Story');
        const { Passage } = require('../../src/Passage');
        
        try {
            const storyData = this.parseTweeContent(tweeContent);
            
            // Create story instance
            const story = new Story();
            story.name = storyData.title || 'Untitled Story';
            
            // Add passages
            for (const passageData of storyData.passages) {
                const passage = new Passage(
                    passageData.name,
                    passageData.content.trim(),
                    passageData.tags
                );
                story.passages[passageData.name] = passage;
            }
            
            // Set start passage
            const startPassage = storyData.passages.find(p => p.name === 'Start');
            if (startPassage) {
                story.startPassage = 'Start';
            }
            
            // Generate HTML template
            const template = this.generateHtmlTemplate(story, storyData);
            return template;
            
        } catch (error) {
            throw new Error(`Story class compilation failed: ${error.message}`);
        }
    }

    /**
     * Generate HTML template for a story
     * @param {Story} story - Story instance
     * @param {Object} storyData - Parsed story data
     * @returns {string} HTML template
     */
    generateHtmlTemplate(story, storyData) {
        const userScript = storyData.passages.find(p => p.name === 'UserScript');
        const header = storyData.passages.find(p => p.name === 'Header');
        
        const html = `<!DOCTYPE html>
<html>
<head>
    <title>${storyData.title || 'Untitled Story'}</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Snowman CSS -->
    <style>
        ${this.getSnowmanCSS()}
    </style>
    
    ${header ? `<!-- Header -->\n    ${header.content}` : ''}
</head>
<body>
    <!-- Story content will be inserted here -->
    <div id="page">
        <div id="story">
            <div id="current-passage"></div>
        </div>
        <div id="sidebar">
            <h1 id="story-title">${storyData.title || 'Untitled Story'}</h1>
            <div id="sidebar-content"></div>
        </div>
    </div>
    
    <!-- Story data -->
    <script type="application/json" id="story-data">
${JSON.stringify({
    name: storyData.title || 'Untitled Story',
    startPassage: 'Start',
    passages: storyData.passages.filter(p => !['UserScript', 'Header', 'StoryTitle', 'StoryAuthor'].includes(p.name))
}, null, 2)}
    </script>
    
    <!-- Snowman runtime (would normally be included here) -->
    <script>
        // This would normally include the full Snowman runtime
        console.log('Snowman story loaded:', ${JSON.stringify(storyData.title || 'Untitled Story')});
    </script>
    
    ${userScript ? `<!-- User Script -->\n    <script>\n${userScript.content}\n    </script>` : ''}
</body>
</html>`;
        
        return html;
    }

    /**
     * Get basic Snowman CSS
     * @returns {string} CSS content
     */
    getSnowmanCSS() {
        // Basic Snowman styling
        return `
            body {
                font-family: Georgia, serif;
                font-size: 18px;
                line-height: 1.4;
                margin: 0;
                padding: 20px;
            }
            
            #page {
                display: flex;
                max-width: 1200px;
                margin: 0 auto;
            }
            
            #story {
                flex: 1;
                margin-right: 20px;
            }
            
            #sidebar {
                width: 200px;
                padding: 20px;
                background: #f5f5f5;
            }
            
            #story-title {
                margin: 0 0 20px 0;
                font-size: 24px;
            }
            
            .passage {
                margin-bottom: 20px;
            }
            
            a {
                color: #0066cc;
                text-decoration: underline;
            }
            
            a:hover {
                color: #004499;
            }
        `;
    }

    /**
     * Generate a valid IFID for the story
     * @returns {string} Generated IFID
     */
    generateIFID() {
        // Generate a UUID-like IFID
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        }).toUpperCase();
    }

    /**
     * Clean up temporary files
     * @param {Array<string>} files - Array of file paths to delete
     */
    cleanupTempFiles(files) {
        for (const file of files) {
            try {
                if (fs.existsSync(file)) {
                    fs.unlinkSync(file);
                }
            } catch (error) {
                console.warn(`Failed to clean up temp file ${file}:`, error.message);
            }
        }
    }

    /**
     * Batch compile multiple Twee files
     * @param {Array<string>} tweeFiles - Array of Twee file paths
     * @param {Object} options - Compilation options
     * @returns {Promise<Array<Object>>} Array of compilation results
     */
    async batchCompile(tweeFiles, options = {}) {
        const results = [];
        
        for (const tweeFile of tweeFiles) {
            try {
                const html = await this.compileTweeFile(tweeFile, options);
                results.push({
                    input: tweeFile,
                    success: true,
                    html: html,
                    error: null
                });
            } catch (error) {
                results.push({
                    input: tweeFile,
                    success: false,
                    html: null,
                    error: error.message
                });
            }
        }
        
        return results;
    }
}

module.exports = { TweeCompiler };